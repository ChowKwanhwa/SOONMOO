{"ast":null,"code":"import { createDefaultAddressSelector, createDefaultAuthorizationResultCache, createDefaultWalletNotFoundHandler, SolanaMobileWalletAdapter, SolanaMobileWalletAdapterWalletName } from '@solana-mobile/wallet-adapter-mobile';\nimport { useStandardWalletAdapters } from '@solana/wallet-standard-wallet-adapter-react';\nimport React, { useCallback, useEffect, useMemo, useRef } from 'react';\nimport getEnvironment, { Environment } from './getEnvironment.js';\nimport getInferredClusterFromEndpoint from './getInferredClusterFromEndpoint.js';\nimport { useConnection } from './useConnection.js';\nimport { useLocalStorage } from './useLocalStorage.js';\nimport { WalletProviderBase } from './WalletProviderBase.js';\nlet _userAgent;\nfunction getUserAgent() {\n  if (_userAgent === undefined) {\n    var _globalThis$navigator, _globalThis$navigator2;\n    _userAgent = (_globalThis$navigator = (_globalThis$navigator2 = globalThis.navigator) === null || _globalThis$navigator2 === void 0 ? void 0 : _globalThis$navigator2.userAgent) !== null && _globalThis$navigator !== void 0 ? _globalThis$navigator : null;\n  }\n  return _userAgent;\n}\nfunction getIsMobile(adapters) {\n  const userAgentString = getUserAgent();\n  return getEnvironment({\n    adapters,\n    userAgentString\n  }) === Environment.MOBILE_WEB;\n}\nfunction getUriForAppIdentity() {\n  const location = globalThis.location;\n  if (!location) return;\n  return \"\".concat(location.protocol, \"//\").concat(location.host);\n}\nexport function WalletProvider(_ref) {\n  let {\n    children,\n    wallets: adapters,\n    autoConnect,\n    localStorageKey = 'walletName',\n    onError\n  } = _ref;\n  const {\n    connection\n  } = useConnection();\n  const adaptersWithStandardAdapters = useStandardWalletAdapters(adapters);\n  const mobileWalletAdapter = useMemo(() => {\n    if (!getIsMobile(adaptersWithStandardAdapters)) {\n      return null;\n    }\n    const existingMobileWalletAdapter = adaptersWithStandardAdapters.find(adapter => adapter.name === SolanaMobileWalletAdapterWalletName);\n    if (existingMobileWalletAdapter) {\n      return existingMobileWalletAdapter;\n    }\n    return new SolanaMobileWalletAdapter({\n      addressSelector: createDefaultAddressSelector(),\n      appIdentity: {\n        uri: getUriForAppIdentity()\n      },\n      authorizationResultCache: createDefaultAuthorizationResultCache(),\n      cluster: getInferredClusterFromEndpoint(connection === null || connection === void 0 ? void 0 : connection.rpcEndpoint),\n      onWalletNotFound: createDefaultWalletNotFoundHandler()\n    });\n  }, [adaptersWithStandardAdapters, connection === null || connection === void 0 ? void 0 : connection.rpcEndpoint]);\n  const adaptersWithMobileWalletAdapter = useMemo(() => {\n    if (mobileWalletAdapter == null || adaptersWithStandardAdapters.indexOf(mobileWalletAdapter) !== -1) {\n      return adaptersWithStandardAdapters;\n    }\n    return [mobileWalletAdapter, ...adaptersWithStandardAdapters];\n  }, [adaptersWithStandardAdapters, mobileWalletAdapter]);\n  const [walletName, setWalletName] = useLocalStorage(localStorageKey, getIsMobile(adaptersWithStandardAdapters) ? SolanaMobileWalletAdapterWalletName : null);\n  const adapter = useMemo(() => {\n    var _adaptersWithMobileWa;\n    return (_adaptersWithMobileWa = adaptersWithMobileWalletAdapter.find(a => a.name === walletName)) !== null && _adaptersWithMobileWa !== void 0 ? _adaptersWithMobileWa : null;\n  }, [adaptersWithMobileWalletAdapter, walletName]);\n  const changeWallet = useCallback(nextWalletName => {\n    if (walletName === nextWalletName) return;\n    if (adapter &&\n    // Selecting a wallet other than the mobile wallet adapter is not\n    // sufficient reason to call `disconnect` on the mobile wallet adapter.\n    // Calling `disconnect` on the mobile wallet adapter causes the entire\n    // authorization store to be wiped.\n    adapter.name !== SolanaMobileWalletAdapterWalletName) {\n      adapter.disconnect();\n    }\n    setWalletName(nextWalletName);\n  }, [adapter, setWalletName, walletName]);\n  useEffect(() => {\n    if (!adapter) return;\n    function handleDisconnect() {\n      if (isUnloadingRef.current) return;\n      // Leave the adapter selected in the event of a disconnection.\n      if (walletName === SolanaMobileWalletAdapterWalletName && getIsMobile(adaptersWithStandardAdapters)) return;\n      setWalletName(null);\n    }\n    adapter.on('disconnect', handleDisconnect);\n    return () => {\n      adapter.off('disconnect', handleDisconnect);\n    };\n  }, [adapter, adaptersWithStandardAdapters, setWalletName, walletName]);\n  const hasUserSelectedAWallet = useRef(false);\n  const handleAutoConnectRequest = useMemo(() => {\n    if (!autoConnect || !adapter) return;\n    return async () => {\n      // If autoConnect is true or returns true, use the default autoConnect behavior.\n      if (autoConnect === true || (await autoConnect(adapter))) {\n        if (hasUserSelectedAWallet.current) {\n          await adapter.connect();\n        } else {\n          await adapter.autoConnect();\n        }\n      }\n    };\n  }, [autoConnect, adapter]);\n  const isUnloadingRef = useRef(false);\n  useEffect(() => {\n    if (walletName === SolanaMobileWalletAdapterWalletName && getIsMobile(adaptersWithStandardAdapters)) {\n      isUnloadingRef.current = false;\n      return;\n    }\n    function handleBeforeUnload() {\n      isUnloadingRef.current = true;\n    }\n    /**\n     * Some wallets fire disconnection events when the window unloads. Since there's no way to\n     * distinguish between a disconnection event received because a user initiated it, and one\n     * that was received because they've closed the window, we have to track window unload\n     * events themselves. Downstream components use this information to decide whether to act\n     * upon or drop wallet events and errors.\n     */\n    window.addEventListener('beforeunload', handleBeforeUnload);\n    return () => {\n      window.removeEventListener('beforeunload', handleBeforeUnload);\n    };\n  }, [adaptersWithStandardAdapters, walletName]);\n  const handleConnectError = useCallback(() => {\n    if (adapter && adapter.name !== SolanaMobileWalletAdapterWalletName) {\n      // If any error happens while connecting, unset the adapter.\n      changeWallet(null);\n    }\n  }, [adapter, changeWallet]);\n  const selectWallet = useCallback(walletName => {\n    hasUserSelectedAWallet.current = true;\n    changeWallet(walletName);\n  }, [changeWallet]);\n  return React.createElement(WalletProviderBase, {\n    wallets: adaptersWithMobileWalletAdapter,\n    adapter: adapter,\n    isUnloadingRef: isUnloadingRef,\n    onAutoConnectRequest: handleAutoConnectRequest,\n    onConnectError: handleConnectError,\n    onError: onError,\n    onSelectWallet: selectWallet\n  }, children);\n}","map":{"version":3,"names":["createDefaultAddressSelector","createDefaultAuthorizationResultCache","createDefaultWalletNotFoundHandler","SolanaMobileWalletAdapter","SolanaMobileWalletAdapterWalletName","useStandardWalletAdapters","React","useCallback","useEffect","useMemo","useRef","getEnvironment","Environment","getInferredClusterFromEndpoint","useConnection","useLocalStorage","WalletProviderBase","_userAgent","getUserAgent","undefined","_globalThis$navigator","_globalThis$navigator2","globalThis","navigator","userAgent","getIsMobile","adapters","userAgentString","MOBILE_WEB","getUriForAppIdentity","location","concat","protocol","host","WalletProvider","_ref","children","wallets","autoConnect","localStorageKey","onError","connection","adaptersWithStandardAdapters","mobileWalletAdapter","existingMobileWalletAdapter","find","adapter","name","addressSelector","appIdentity","uri","authorizationResultCache","cluster","rpcEndpoint","onWalletNotFound","adaptersWithMobileWalletAdapter","indexOf","walletName","setWalletName","_adaptersWithMobileWa","a","changeWallet","nextWalletName","disconnect","handleDisconnect","isUnloadingRef","current","on","off","hasUserSelectedAWallet","handleAutoConnectRequest","connect","handleBeforeUnload","window","addEventListener","removeEventListener","handleConnectError","selectWallet","createElement","onAutoConnectRequest","onConnectError","onSelectWallet"],"sources":["/workspaces/SOONMOO/node_modules/@solana/wallet-adapter-react/src/WalletProvider.tsx"],"sourcesContent":["import {\n    createDefaultAddressSelector,\n    createDefaultAuthorizationResultCache,\n    createDefaultWalletNotFoundHandler,\n    SolanaMobileWalletAdapter,\n    SolanaMobileWalletAdapterWalletName,\n} from '@solana-mobile/wallet-adapter-mobile';\nimport { type Adapter, type WalletError, type WalletName } from '@solana/wallet-adapter-base';\nimport { useStandardWalletAdapters } from '@solana/wallet-standard-wallet-adapter-react';\nimport React, { type ReactNode, useCallback, useEffect, useMemo, useRef } from 'react';\nimport getEnvironment, { Environment } from './getEnvironment.js';\nimport getInferredClusterFromEndpoint from './getInferredClusterFromEndpoint.js';\nimport { useConnection } from './useConnection.js';\nimport { useLocalStorage } from './useLocalStorage.js';\nimport { WalletProviderBase } from './WalletProviderBase.js';\n\nexport interface WalletProviderProps {\n    children: ReactNode;\n    wallets: Adapter[];\n    autoConnect?: boolean | ((adapter: Adapter) => Promise<boolean>);\n    localStorageKey?: string;\n    onError?: (error: WalletError, adapter?: Adapter) => void;\n}\n\nlet _userAgent: string | null;\nfunction getUserAgent() {\n    if (_userAgent === undefined) {\n        _userAgent = globalThis.navigator?.userAgent ?? null;\n    }\n    return _userAgent;\n}\n\nfunction getIsMobile(adapters: Adapter[]) {\n    const userAgentString = getUserAgent();\n    return getEnvironment({ adapters, userAgentString }) === Environment.MOBILE_WEB;\n}\n\nfunction getUriForAppIdentity() {\n    const location = globalThis.location;\n    if (!location) return;\n    return `${location.protocol}//${location.host}`;\n}\n\nexport function WalletProvider({\n    children,\n    wallets: adapters,\n    autoConnect,\n    localStorageKey = 'walletName',\n    onError,\n}: WalletProviderProps) {\n    const { connection } = useConnection();\n    const adaptersWithStandardAdapters = useStandardWalletAdapters(adapters);\n    const mobileWalletAdapter = useMemo(() => {\n        if (!getIsMobile(adaptersWithStandardAdapters)) {\n            return null;\n        }\n        const existingMobileWalletAdapter = adaptersWithStandardAdapters.find(\n            (adapter) => adapter.name === SolanaMobileWalletAdapterWalletName\n        );\n        if (existingMobileWalletAdapter) {\n            return existingMobileWalletAdapter;\n        }\n        return new SolanaMobileWalletAdapter({\n            addressSelector: createDefaultAddressSelector(),\n            appIdentity: {\n                uri: getUriForAppIdentity(),\n            },\n            authorizationResultCache: createDefaultAuthorizationResultCache(),\n            cluster: getInferredClusterFromEndpoint(connection?.rpcEndpoint),\n            onWalletNotFound: createDefaultWalletNotFoundHandler(),\n        });\n    }, [adaptersWithStandardAdapters, connection?.rpcEndpoint]);\n    const adaptersWithMobileWalletAdapter = useMemo(() => {\n        if (mobileWalletAdapter == null || adaptersWithStandardAdapters.indexOf(mobileWalletAdapter) !== -1) {\n            return adaptersWithStandardAdapters;\n        }\n        return [mobileWalletAdapter, ...adaptersWithStandardAdapters];\n    }, [adaptersWithStandardAdapters, mobileWalletAdapter]);\n    const [walletName, setWalletName] = useLocalStorage<WalletName | null>(\n        localStorageKey,\n        getIsMobile(adaptersWithStandardAdapters) ? SolanaMobileWalletAdapterWalletName : null\n    );\n    const adapter = useMemo(\n        () => adaptersWithMobileWalletAdapter.find((a) => a.name === walletName) ?? null,\n        [adaptersWithMobileWalletAdapter, walletName]\n    );\n    const changeWallet = useCallback(\n        (nextWalletName: WalletName<string> | null) => {\n            if (walletName === nextWalletName) return;\n            if (\n                adapter &&\n                // Selecting a wallet other than the mobile wallet adapter is not\n                // sufficient reason to call `disconnect` on the mobile wallet adapter.\n                // Calling `disconnect` on the mobile wallet adapter causes the entire\n                // authorization store to be wiped.\n                adapter.name !== SolanaMobileWalletAdapterWalletName\n            ) {\n                adapter.disconnect();\n            }\n            setWalletName(nextWalletName);\n        },\n        [adapter, setWalletName, walletName]\n    );\n    useEffect(() => {\n        if (!adapter) return;\n        function handleDisconnect() {\n            if (isUnloadingRef.current) return;\n            // Leave the adapter selected in the event of a disconnection.\n            if (walletName === SolanaMobileWalletAdapterWalletName && getIsMobile(adaptersWithStandardAdapters)) return;\n            setWalletName(null);\n        }\n        adapter.on('disconnect', handleDisconnect);\n        return () => {\n            adapter.off('disconnect', handleDisconnect);\n        };\n    }, [adapter, adaptersWithStandardAdapters, setWalletName, walletName]);\n    const hasUserSelectedAWallet = useRef(false);\n    const handleAutoConnectRequest = useMemo(() => {\n        if (!autoConnect || !adapter) return;\n        return async () => {\n            // If autoConnect is true or returns true, use the default autoConnect behavior.\n            if (autoConnect === true || (await autoConnect(adapter))) {\n                if (hasUserSelectedAWallet.current) {\n                    await adapter.connect();\n                } else {\n                    await adapter.autoConnect();\n                }\n            }\n        };\n    }, [autoConnect, adapter]);\n    const isUnloadingRef = useRef(false);\n    useEffect(() => {\n        if (walletName === SolanaMobileWalletAdapterWalletName && getIsMobile(adaptersWithStandardAdapters)) {\n            isUnloadingRef.current = false;\n            return;\n        }\n        function handleBeforeUnload() {\n            isUnloadingRef.current = true;\n        }\n        /**\n         * Some wallets fire disconnection events when the window unloads. Since there's no way to\n         * distinguish between a disconnection event received because a user initiated it, and one\n         * that was received because they've closed the window, we have to track window unload\n         * events themselves. Downstream components use this information to decide whether to act\n         * upon or drop wallet events and errors.\n         */\n        window.addEventListener('beforeunload', handleBeforeUnload);\n        return () => {\n            window.removeEventListener('beforeunload', handleBeforeUnload);\n        };\n    }, [adaptersWithStandardAdapters, walletName]);\n    const handleConnectError = useCallback(() => {\n        if (adapter && adapter.name !== SolanaMobileWalletAdapterWalletName) {\n            // If any error happens while connecting, unset the adapter.\n            changeWallet(null);\n        }\n    }, [adapter, changeWallet]);\n    const selectWallet = useCallback(\n        (walletName: WalletName | null) => {\n            hasUserSelectedAWallet.current = true;\n            changeWallet(walletName);\n        },\n        [changeWallet]\n    );\n    return (\n        <WalletProviderBase\n            wallets={adaptersWithMobileWalletAdapter}\n            adapter={adapter}\n            isUnloadingRef={isUnloadingRef}\n            onAutoConnectRequest={handleAutoConnectRequest}\n            onConnectError={handleConnectError}\n            onError={onError}\n            onSelectWallet={selectWallet}\n        >\n            {children}\n        </WalletProviderBase>\n    );\n}\n"],"mappings":"AAAA,SACIA,4BAA4B,EAC5BC,qCAAqC,EACrCC,kCAAkC,EAClCC,yBAAyB,EACzBC,mCAAmC,QAChC,sCAAsC;AAE7C,SAASC,yBAAyB,QAAQ,8CAA8C;AACxF,OAAOC,KAAK,IAAoBC,WAAW,EAAEC,SAAS,EAAEC,OAAO,EAAEC,MAAM,QAAQ,OAAO;AACtF,OAAOC,cAAc,IAAIC,WAAW,QAAQ,qBAAqB;AACjE,OAAOC,8BAA8B,MAAM,qCAAqC;AAChF,SAASC,aAAa,QAAQ,oBAAoB;AAClD,SAASC,eAAe,QAAQ,sBAAsB;AACtD,SAASC,kBAAkB,QAAQ,yBAAyB;AAU5D,IAAIC,UAAyB;AAC7B,SAASC,YAAYA,CAAA;EACjB,IAAID,UAAU,KAAKE,SAAS,EAAE;IAAA,IAAAC,qBAAA,EAAAC,sBAAA;IAC1BJ,UAAU,IAAAG,qBAAA,IAAAC,sBAAA,GAAGC,UAAU,CAACC,SAAS,cAAAF,sBAAA,uBAApBA,sBAAA,CAAsBG,SAAS,cAAAJ,qBAAA,cAAAA,qBAAA,GAAI,IAAI;;EAExD,OAAOH,UAAU;AACrB;AAEA,SAASQ,WAAWA,CAACC,QAAmB;EACpC,MAAMC,eAAe,GAAGT,YAAY,EAAE;EACtC,OAAOP,cAAc,CAAC;IAAEe,QAAQ;IAAEC;EAAe,CAAE,CAAC,KAAKf,WAAW,CAACgB,UAAU;AACnF;AAEA,SAASC,oBAAoBA,CAAA;EACzB,MAAMC,QAAQ,GAAGR,UAAU,CAACQ,QAAQ;EACpC,IAAI,CAACA,QAAQ,EAAE;EACf,UAAAC,MAAA,CAAUD,QAAQ,CAACE,QAAQ,QAAAD,MAAA,CAAKD,QAAQ,CAACG,IAAI;AACjD;AAEA,OAAM,SAAUC,cAAcA,CAAAC,IAAA,EAMR;EAAA,IANS;IAC3BC,QAAQ;IACRC,OAAO,EAAEX,QAAQ;IACjBY,WAAW;IACXC,eAAe,GAAG,YAAY;IAC9BC;EAAO,CACW,GAAAL,IAAA;EAClB,MAAM;IAAEM;EAAU,CAAE,GAAG3B,aAAa,EAAE;EACtC,MAAM4B,4BAA4B,GAAGrC,yBAAyB,CAACqB,QAAQ,CAAC;EACxE,MAAMiB,mBAAmB,GAAGlC,OAAO,CAAC,MAAK;IACrC,IAAI,CAACgB,WAAW,CAACiB,4BAA4B,CAAC,EAAE;MAC5C,OAAO,IAAI;;IAEf,MAAME,2BAA2B,GAAGF,4BAA4B,CAACG,IAAI,CAChEC,OAAO,IAAKA,OAAO,CAACC,IAAI,KAAK3C,mCAAmC,CACpE;IACD,IAAIwC,2BAA2B,EAAE;MAC7B,OAAOA,2BAA2B;;IAEtC,OAAO,IAAIzC,yBAAyB,CAAC;MACjC6C,eAAe,EAAEhD,4BAA4B,EAAE;MAC/CiD,WAAW,EAAE;QACTC,GAAG,EAAErB,oBAAoB;OAC5B;MACDsB,wBAAwB,EAAElD,qCAAqC,EAAE;MACjEmD,OAAO,EAAEvC,8BAA8B,CAAC4B,UAAU,aAAVA,UAAU,uBAAVA,UAAU,CAAEY,WAAW,CAAC;MAChEC,gBAAgB,EAAEpD,kCAAkC;KACvD,CAAC;EACN,CAAC,EAAE,CAACwC,4BAA4B,EAAED,UAAU,aAAVA,UAAU,uBAAVA,UAAU,CAAEY,WAAW,CAAC,CAAC;EAC3D,MAAME,+BAA+B,GAAG9C,OAAO,CAAC,MAAK;IACjD,IAAIkC,mBAAmB,IAAI,IAAI,IAAID,4BAA4B,CAACc,OAAO,CAACb,mBAAmB,CAAC,KAAK,CAAC,CAAC,EAAE;MACjG,OAAOD,4BAA4B;;IAEvC,OAAO,CAACC,mBAAmB,EAAE,GAAGD,4BAA4B,CAAC;EACjE,CAAC,EAAE,CAACA,4BAA4B,EAAEC,mBAAmB,CAAC,CAAC;EACvD,MAAM,CAACc,UAAU,EAAEC,aAAa,CAAC,GAAG3C,eAAe,CAC/CwB,eAAe,EACfd,WAAW,CAACiB,4BAA4B,CAAC,GAAGtC,mCAAmC,GAAG,IAAI,CACzF;EACD,MAAM0C,OAAO,GAAGrC,OAAO,CACnB;IAAA,IAAAkD,qBAAA;IAAA,QAAAA,qBAAA,GAAMJ,+BAA+B,CAACV,IAAI,CAAEe,CAAC,IAAKA,CAAC,CAACb,IAAI,KAAKU,UAAU,CAAC,cAAAE,qBAAA,cAAAA,qBAAA,GAAI,IAAI;EAAA,GAChF,CAACJ,+BAA+B,EAAEE,UAAU,CAAC,CAChD;EACD,MAAMI,YAAY,GAAGtD,WAAW,CAC3BuD,cAAyC,IAAI;IAC1C,IAAIL,UAAU,KAAKK,cAAc,EAAE;IACnC,IACIhB,OAAO;IACP;IACA;IACA;IACA;IACAA,OAAO,CAACC,IAAI,KAAK3C,mCAAmC,EACtD;MACE0C,OAAO,CAACiB,UAAU,EAAE;;IAExBL,aAAa,CAACI,cAAc,CAAC;EACjC,CAAC,EACD,CAAChB,OAAO,EAAEY,aAAa,EAAED,UAAU,CAAC,CACvC;EACDjD,SAAS,CAAC,MAAK;IACX,IAAI,CAACsC,OAAO,EAAE;IACd,SAASkB,gBAAgBA,CAAA;MACrB,IAAIC,cAAc,CAACC,OAAO,EAAE;MAC5B;MACA,IAAIT,UAAU,KAAKrD,mCAAmC,IAAIqB,WAAW,CAACiB,4BAA4B,CAAC,EAAE;MACrGgB,aAAa,CAAC,IAAI,CAAC;IACvB;IACAZ,OAAO,CAACqB,EAAE,CAAC,YAAY,EAAEH,gBAAgB,CAAC;IAC1C,OAAO,MAAK;MACRlB,OAAO,CAACsB,GAAG,CAAC,YAAY,EAAEJ,gBAAgB,CAAC;IAC/C,CAAC;EACL,CAAC,EAAE,CAAClB,OAAO,EAAEJ,4BAA4B,EAAEgB,aAAa,EAAED,UAAU,CAAC,CAAC;EACtE,MAAMY,sBAAsB,GAAG3D,MAAM,CAAC,KAAK,CAAC;EAC5C,MAAM4D,wBAAwB,GAAG7D,OAAO,CAAC,MAAK;IAC1C,IAAI,CAAC6B,WAAW,IAAI,CAACQ,OAAO,EAAE;IAC9B,OAAO,YAAW;MACd;MACA,IAAIR,WAAW,KAAK,IAAI,KAAK,MAAMA,WAAW,CAACQ,OAAO,CAAC,CAAC,EAAE;QACtD,IAAIuB,sBAAsB,CAACH,OAAO,EAAE;UAChC,MAAMpB,OAAO,CAACyB,OAAO,EAAE;SAC1B,MAAM;UACH,MAAMzB,OAAO,CAACR,WAAW,EAAE;;;IAGvC,CAAC;EACL,CAAC,EAAE,CAACA,WAAW,EAAEQ,OAAO,CAAC,CAAC;EAC1B,MAAMmB,cAAc,GAAGvD,MAAM,CAAC,KAAK,CAAC;EACpCF,SAAS,CAAC,MAAK;IACX,IAAIiD,UAAU,KAAKrD,mCAAmC,IAAIqB,WAAW,CAACiB,4BAA4B,CAAC,EAAE;MACjGuB,cAAc,CAACC,OAAO,GAAG,KAAK;MAC9B;;IAEJ,SAASM,kBAAkBA,CAAA;MACvBP,cAAc,CAACC,OAAO,GAAG,IAAI;IACjC;IACA;;;;;;;IAOAO,MAAM,CAACC,gBAAgB,CAAC,cAAc,EAAEF,kBAAkB,CAAC;IAC3D,OAAO,MAAK;MACRC,MAAM,CAACE,mBAAmB,CAAC,cAAc,EAAEH,kBAAkB,CAAC;IAClE,CAAC;EACL,CAAC,EAAE,CAAC9B,4BAA4B,EAAEe,UAAU,CAAC,CAAC;EAC9C,MAAMmB,kBAAkB,GAAGrE,WAAW,CAAC,MAAK;IACxC,IAAIuC,OAAO,IAAIA,OAAO,CAACC,IAAI,KAAK3C,mCAAmC,EAAE;MACjE;MACAyD,YAAY,CAAC,IAAI,CAAC;;EAE1B,CAAC,EAAE,CAACf,OAAO,EAAEe,YAAY,CAAC,CAAC;EAC3B,MAAMgB,YAAY,GAAGtE,WAAW,CAC3BkD,UAA6B,IAAI;IAC9BY,sBAAsB,CAACH,OAAO,GAAG,IAAI;IACrCL,YAAY,CAACJ,UAAU,CAAC;EAC5B,CAAC,EACD,CAACI,YAAY,CAAC,CACjB;EACD,OACIvD,KAAA,CAAAwE,aAAA,CAAC9D,kBAAkB;IACfqB,OAAO,EAAEkB,+BAA+B;IACxCT,OAAO,EAAEA,OAAO;IAChBmB,cAAc,EAAEA,cAAc;IAC9Bc,oBAAoB,EAAET,wBAAwB;IAC9CU,cAAc,EAAEJ,kBAAkB;IAClCpC,OAAO,EAAEA,OAAO;IAChByC,cAAc,EAAEJ;EAAY,GAE3BzC,QAAQ,CACQ;AAE7B","ignoreList":[]},"metadata":{},"sourceType":"module"}