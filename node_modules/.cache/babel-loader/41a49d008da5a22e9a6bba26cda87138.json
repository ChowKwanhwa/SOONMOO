{"ast":null,"code":"import { WalletNotConnectedError, WalletNotReadyError, WalletReadyState } from '@solana/wallet-adapter-base';\nimport React, { useCallback, useEffect, useMemo, useRef, useState } from 'react';\nimport { WalletNotSelectedError } from './errors.js';\nimport { WalletContext } from './useWallet.js';\nexport function WalletProviderBase(_ref) {\n  let {\n    children,\n    wallets: adapters,\n    adapter,\n    isUnloadingRef,\n    onAutoConnectRequest,\n    onConnectError,\n    onError,\n    onSelectWallet\n  } = _ref;\n  const isConnectingRef = useRef(false);\n  const [connecting, setConnecting] = useState(false);\n  const isDisconnectingRef = useRef(false);\n  const [disconnecting, setDisconnecting] = useState(false);\n  const [publicKey, setPublicKey] = useState(() => {\n    var _adapter$publicKey;\n    return (_adapter$publicKey = adapter === null || adapter === void 0 ? void 0 : adapter.publicKey) !== null && _adapter$publicKey !== void 0 ? _adapter$publicKey : null;\n  });\n  const [connected, setConnected] = useState(() => {\n    var _adapter$connected;\n    return (_adapter$connected = adapter === null || adapter === void 0 ? void 0 : adapter.connected) !== null && _adapter$connected !== void 0 ? _adapter$connected : false;\n  });\n  /**\n   * Store the error handlers as refs so that a change in the\n   * custom error handler does not recompute other dependencies.\n   */\n  const onErrorRef = useRef(onError);\n  useEffect(() => {\n    onErrorRef.current = onError;\n    return () => {\n      onErrorRef.current = undefined;\n    };\n  }, [onError]);\n  const handleErrorRef = useRef((error, adapter) => {\n    if (!isUnloadingRef.current) {\n      if (onErrorRef.current) {\n        onErrorRef.current(error, adapter);\n      } else {\n        console.error(error, adapter);\n        if (error instanceof WalletNotReadyError && typeof window !== 'undefined' && adapter) {\n          window.open(adapter.url, '_blank');\n        }\n      }\n    }\n    return error;\n  });\n  // Wrap adapters to conform to the `Wallet` interface\n  const [wallets, setWallets] = useState(() => adapters.map(adapter => ({\n    adapter,\n    readyState: adapter.readyState\n  })).filter(_ref2 => {\n    let {\n      readyState\n    } = _ref2;\n    return readyState !== WalletReadyState.Unsupported;\n  }));\n  // When the adapters change, start to listen for changes to their `readyState`\n  useEffect(() => {\n    // When the adapters change, wrap them to conform to the `Wallet` interface\n    setWallets(wallets => adapters.map((adapter, index) => {\n      const wallet = wallets[index];\n      // If the wallet hasn't changed, return the same instance\n      return wallet && wallet.adapter === adapter && wallet.readyState === adapter.readyState ? wallet : {\n        adapter: adapter,\n        readyState: adapter.readyState\n      };\n    }).filter(_ref3 => {\n      let {\n        readyState\n      } = _ref3;\n      return readyState !== WalletReadyState.Unsupported;\n    }));\n    function handleReadyStateChange(readyState) {\n      setWallets(prevWallets => {\n        const index = prevWallets.findIndex(_ref4 => {\n          let {\n            adapter\n          } = _ref4;\n          return adapter === this;\n        });\n        if (index === -1) return prevWallets;\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        const {\n          adapter\n        } = prevWallets[index];\n        return [...prevWallets.slice(0, index), {\n          adapter,\n          readyState\n        }, ...prevWallets.slice(index + 1)].filter(_ref5 => {\n          let {\n            readyState\n          } = _ref5;\n          return readyState !== WalletReadyState.Unsupported;\n        });\n      });\n    }\n    adapters.forEach(adapter => adapter.on('readyStateChange', handleReadyStateChange, adapter));\n    return () => {\n      adapters.forEach(adapter => adapter.off('readyStateChange', handleReadyStateChange, adapter));\n    };\n  }, [adapter, adapters]);\n  const wallet = useMemo(() => {\n    var _wallets$find;\n    return (_wallets$find = wallets.find(wallet => wallet.adapter === adapter)) !== null && _wallets$find !== void 0 ? _wallets$find : null;\n  }, [adapter, wallets]);\n  // Setup and teardown event listeners when the adapter changes\n  useEffect(() => {\n    if (!adapter) return;\n    const handleConnect = publicKey => {\n      setPublicKey(publicKey);\n      isConnectingRef.current = false;\n      setConnecting(false);\n      setConnected(true);\n      isDisconnectingRef.current = false;\n      setDisconnecting(false);\n    };\n    const handleDisconnect = () => {\n      if (isUnloadingRef.current) return;\n      setPublicKey(null);\n      isConnectingRef.current = false;\n      setConnecting(false);\n      setConnected(false);\n      isDisconnectingRef.current = false;\n      setDisconnecting(false);\n    };\n    const handleError = error => {\n      handleErrorRef.current(error, adapter);\n    };\n    adapter.on('connect', handleConnect);\n    adapter.on('disconnect', handleDisconnect);\n    adapter.on('error', handleError);\n    return () => {\n      adapter.off('connect', handleConnect);\n      adapter.off('disconnect', handleDisconnect);\n      adapter.off('error', handleError);\n      handleDisconnect();\n    };\n  }, [adapter, isUnloadingRef]);\n  // When the adapter changes, clear the `autoConnect` tracking flag\n  const didAttemptAutoConnectRef = useRef(false);\n  useEffect(() => {\n    return () => {\n      didAttemptAutoConnectRef.current = false;\n    };\n  }, [adapter]);\n  // If auto-connect is enabled, request to connect when the adapter changes and is ready\n  useEffect(() => {\n    if (didAttemptAutoConnectRef.current || isConnectingRef.current || connected || !onAutoConnectRequest || !((wallet === null || wallet === void 0 ? void 0 : wallet.readyState) === WalletReadyState.Installed || (wallet === null || wallet === void 0 ? void 0 : wallet.readyState) === WalletReadyState.Loadable)) return;\n    isConnectingRef.current = true;\n    setConnecting(true);\n    didAttemptAutoConnectRef.current = true;\n    (async function () {\n      try {\n        await onAutoConnectRequest();\n      } catch {\n        onConnectError();\n        // Drop the error. It will be caught by `handleError` anyway.\n      } finally {\n        setConnecting(false);\n        isConnectingRef.current = false;\n      }\n    })();\n  }, [connected, onAutoConnectRequest, onConnectError, wallet]);\n  // Send a transaction using the provided connection\n  const sendTransaction = useCallback(async (transaction, connection, options) => {\n    if (!adapter) throw handleErrorRef.current(new WalletNotSelectedError());\n    if (!connected) throw handleErrorRef.current(new WalletNotConnectedError(), adapter);\n    return await adapter.sendTransaction(transaction, connection, options);\n  }, [adapter, connected]);\n  // Sign a transaction if the wallet supports it\n  const signTransaction = useMemo(() => adapter && 'signTransaction' in adapter ? async transaction => {\n    if (!connected) throw handleErrorRef.current(new WalletNotConnectedError(), adapter);\n    return await adapter.signTransaction(transaction);\n  } : undefined, [adapter, connected]);\n  // Sign multiple transactions if the wallet supports it\n  const signAllTransactions = useMemo(() => adapter && 'signAllTransactions' in adapter ? async transactions => {\n    if (!connected) throw handleErrorRef.current(new WalletNotConnectedError(), adapter);\n    return await adapter.signAllTransactions(transactions);\n  } : undefined, [adapter, connected]);\n  // Sign an arbitrary message if the wallet supports it\n  const signMessage = useMemo(() => adapter && 'signMessage' in adapter ? async message => {\n    if (!connected) throw handleErrorRef.current(new WalletNotConnectedError(), adapter);\n    return await adapter.signMessage(message);\n  } : undefined, [adapter, connected]);\n  // Sign in if the wallet supports it\n  const signIn = useMemo(() => adapter && 'signIn' in adapter ? async input => {\n    return await adapter.signIn(input);\n  } : undefined, [adapter]);\n  const handleConnect = useCallback(async () => {\n    if (isConnectingRef.current || isDisconnectingRef.current || wallet !== null && wallet !== void 0 && wallet.adapter.connected) return;\n    if (!wallet) throw handleErrorRef.current(new WalletNotSelectedError());\n    const {\n      adapter,\n      readyState\n    } = wallet;\n    if (!(readyState === WalletReadyState.Installed || readyState === WalletReadyState.Loadable)) throw handleErrorRef.current(new WalletNotReadyError(), adapter);\n    isConnectingRef.current = true;\n    setConnecting(true);\n    try {\n      await adapter.connect();\n    } catch (e) {\n      onConnectError();\n      throw e;\n    } finally {\n      setConnecting(false);\n      isConnectingRef.current = false;\n    }\n  }, [onConnectError, wallet]);\n  const handleDisconnect = useCallback(async () => {\n    if (isDisconnectingRef.current) return;\n    if (!adapter) return;\n    isDisconnectingRef.current = true;\n    setDisconnecting(true);\n    try {\n      await adapter.disconnect();\n    } finally {\n      setDisconnecting(false);\n      isDisconnectingRef.current = false;\n    }\n  }, [adapter]);\n  return React.createElement(WalletContext.Provider, {\n    value: {\n      autoConnect: !!onAutoConnectRequest,\n      wallets,\n      wallet,\n      publicKey,\n      connected,\n      connecting,\n      disconnecting,\n      select: onSelectWallet,\n      connect: handleConnect,\n      disconnect: handleDisconnect,\n      sendTransaction,\n      signTransaction,\n      signAllTransactions,\n      signMessage,\n      signIn\n    }\n  }, children);\n}","map":{"version":3,"names":["WalletNotConnectedError","WalletNotReadyError","WalletReadyState","React","useCallback","useEffect","useMemo","useRef","useState","WalletNotSelectedError","WalletContext","WalletProviderBase","_ref","children","wallets","adapters","adapter","isUnloadingRef","onAutoConnectRequest","onConnectError","onError","onSelectWallet","isConnectingRef","connecting","setConnecting","isDisconnectingRef","disconnecting","setDisconnecting","publicKey","setPublicKey","_adapter$publicKey","connected","setConnected","_adapter$connected","onErrorRef","current","undefined","handleErrorRef","error","console","window","open","url","setWallets","map","readyState","filter","_ref2","Unsupported","index","wallet","_ref3","handleReadyStateChange","prevWallets","findIndex","_ref4","slice","_ref5","forEach","on","off","_wallets$find","find","handleConnect","handleDisconnect","handleError","didAttemptAutoConnectRef","Installed","Loadable","sendTransaction","transaction","connection","options","signTransaction","signAllTransactions","transactions","signMessage","message","signIn","input","connect","e","disconnect","createElement","Provider","value","autoConnect","select"],"sources":["/workspaces/SOONMOO/node_modules/@solana/wallet-adapter-react/src/WalletProviderBase.tsx"],"sourcesContent":["import {\n    type Adapter,\n    type MessageSignerWalletAdapterProps,\n    type SignerWalletAdapterProps,\n    type SignInMessageSignerWalletAdapterProps,\n    type WalletAdapterProps,\n    type WalletError,\n    type WalletName,\n    WalletNotConnectedError,\n    WalletNotReadyError,\n    WalletReadyState,\n} from '@solana/wallet-adapter-base';\nimport { type PublicKey } from '@solana/web3.js';\nimport React, { type ReactNode, useCallback, useEffect, useMemo, useRef, useState } from 'react';\nimport { WalletNotSelectedError } from './errors.js';\nimport { WalletContext } from './useWallet.js';\n\nexport interface WalletProviderBaseProps {\n    children: ReactNode;\n    wallets: Adapter[];\n    adapter: Adapter | null;\n    isUnloadingRef: React.RefObject<boolean>;\n    // NOTE: The presence/absence of this handler implies that auto-connect is enabled/disabled.\n    onAutoConnectRequest?: () => Promise<void>;\n    onConnectError: () => void;\n    onError?: (error: WalletError, adapter?: Adapter) => void;\n    onSelectWallet: (walletName: WalletName | null) => void;\n}\n\nexport function WalletProviderBase({\n    children,\n    wallets: adapters,\n    adapter,\n    isUnloadingRef,\n    onAutoConnectRequest,\n    onConnectError,\n    onError,\n    onSelectWallet,\n}: WalletProviderBaseProps) {\n    const isConnectingRef = useRef(false);\n    const [connecting, setConnecting] = useState(false);\n    const isDisconnectingRef = useRef(false);\n    const [disconnecting, setDisconnecting] = useState(false);\n    const [publicKey, setPublicKey] = useState(() => adapter?.publicKey ?? null);\n    const [connected, setConnected] = useState(() => adapter?.connected ?? false);\n\n    /**\n     * Store the error handlers as refs so that a change in the\n     * custom error handler does not recompute other dependencies.\n     */\n    const onErrorRef = useRef(onError);\n    useEffect(() => {\n        onErrorRef.current = onError;\n        return () => {\n            onErrorRef.current = undefined;\n        };\n    }, [onError]);\n    const handleErrorRef = useRef((error: WalletError, adapter?: Adapter) => {\n        if (!isUnloadingRef.current) {\n            if (onErrorRef.current) {\n                onErrorRef.current(error, adapter);\n            } else {\n                console.error(error, adapter);\n                if (error instanceof WalletNotReadyError && typeof window !== 'undefined' && adapter) {\n                    window.open(adapter.url, '_blank');\n                }\n            }\n        }\n        return error;\n    });\n\n    // Wrap adapters to conform to the `Wallet` interface\n    const [wallets, setWallets] = useState(() =>\n        adapters\n            .map((adapter) => ({\n                adapter,\n                readyState: adapter.readyState,\n            }))\n            .filter(({ readyState }) => readyState !== WalletReadyState.Unsupported)\n    );\n\n    // When the adapters change, start to listen for changes to their `readyState`\n    useEffect(() => {\n        // When the adapters change, wrap them to conform to the `Wallet` interface\n        setWallets((wallets) =>\n            adapters\n                .map((adapter, index) => {\n                    const wallet = wallets[index];\n                    // If the wallet hasn't changed, return the same instance\n                    return wallet && wallet.adapter === adapter && wallet.readyState === adapter.readyState\n                        ? wallet\n                        : {\n                              adapter: adapter,\n                              readyState: adapter.readyState,\n                          };\n                })\n                .filter(({ readyState }) => readyState !== WalletReadyState.Unsupported)\n        );\n        function handleReadyStateChange(this: Adapter, readyState: WalletReadyState) {\n            setWallets((prevWallets) => {\n                const index = prevWallets.findIndex(({ adapter }) => adapter === this);\n                if (index === -1) return prevWallets;\n\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                const { adapter } = prevWallets[index]!;\n                return [\n                    ...prevWallets.slice(0, index),\n                    { adapter, readyState },\n                    ...prevWallets.slice(index + 1),\n                ].filter(({ readyState }) => readyState !== WalletReadyState.Unsupported);\n            });\n        }\n        adapters.forEach((adapter) => adapter.on('readyStateChange', handleReadyStateChange, adapter));\n        return () => {\n            adapters.forEach((adapter) => adapter.off('readyStateChange', handleReadyStateChange, adapter));\n        };\n    }, [adapter, adapters]);\n\n    const wallet = useMemo(() => wallets.find((wallet) => wallet.adapter === adapter) ?? null, [adapter, wallets]);\n\n    // Setup and teardown event listeners when the adapter changes\n    useEffect(() => {\n        if (!adapter) return;\n\n        const handleConnect = (publicKey: PublicKey) => {\n            setPublicKey(publicKey);\n            isConnectingRef.current = false;\n            setConnecting(false);\n            setConnected(true);\n            isDisconnectingRef.current = false;\n            setDisconnecting(false);\n        };\n\n        const handleDisconnect = () => {\n            if (isUnloadingRef.current) return;\n\n            setPublicKey(null);\n            isConnectingRef.current = false;\n            setConnecting(false);\n            setConnected(false);\n            isDisconnectingRef.current = false;\n            setDisconnecting(false);\n        };\n\n        const handleError = (error: WalletError) => {\n            handleErrorRef.current(error, adapter);\n        };\n\n        adapter.on('connect', handleConnect);\n        adapter.on('disconnect', handleDisconnect);\n        adapter.on('error', handleError);\n\n        return () => {\n            adapter.off('connect', handleConnect);\n            adapter.off('disconnect', handleDisconnect);\n            adapter.off('error', handleError);\n\n            handleDisconnect();\n        };\n    }, [adapter, isUnloadingRef]);\n\n    // When the adapter changes, clear the `autoConnect` tracking flag\n    const didAttemptAutoConnectRef = useRef(false);\n    useEffect(() => {\n        return () => {\n            didAttemptAutoConnectRef.current = false;\n        };\n    }, [adapter]);\n\n    // If auto-connect is enabled, request to connect when the adapter changes and is ready\n    useEffect(() => {\n        if (\n            didAttemptAutoConnectRef.current ||\n            isConnectingRef.current ||\n            connected ||\n            !onAutoConnectRequest ||\n            !(wallet?.readyState === WalletReadyState.Installed || wallet?.readyState === WalletReadyState.Loadable)\n        )\n            return;\n\n        isConnectingRef.current = true;\n        setConnecting(true);\n        didAttemptAutoConnectRef.current = true;\n        (async function () {\n            try {\n                await onAutoConnectRequest();\n            } catch {\n                onConnectError();\n                // Drop the error. It will be caught by `handleError` anyway.\n            } finally {\n                setConnecting(false);\n                isConnectingRef.current = false;\n            }\n        })();\n    }, [connected, onAutoConnectRequest, onConnectError, wallet]);\n\n    // Send a transaction using the provided connection\n    const sendTransaction: WalletAdapterProps['sendTransaction'] = useCallback(\n        async (transaction, connection, options) => {\n            if (!adapter) throw handleErrorRef.current(new WalletNotSelectedError());\n            if (!connected) throw handleErrorRef.current(new WalletNotConnectedError(), adapter);\n            return await adapter.sendTransaction(transaction, connection, options);\n        },\n        [adapter, connected]\n    );\n\n    // Sign a transaction if the wallet supports it\n    const signTransaction: SignerWalletAdapterProps['signTransaction'] | undefined = useMemo(\n        () =>\n            adapter && 'signTransaction' in adapter\n                ? async (transaction) => {\n                      if (!connected) throw handleErrorRef.current(new WalletNotConnectedError(), adapter);\n                      return await adapter.signTransaction(transaction);\n                  }\n                : undefined,\n        [adapter, connected]\n    );\n\n    // Sign multiple transactions if the wallet supports it\n    const signAllTransactions: SignerWalletAdapterProps['signAllTransactions'] | undefined = useMemo(\n        () =>\n            adapter && 'signAllTransactions' in adapter\n                ? async (transactions) => {\n                      if (!connected) throw handleErrorRef.current(new WalletNotConnectedError(), adapter);\n                      return await adapter.signAllTransactions(transactions);\n                  }\n                : undefined,\n        [adapter, connected]\n    );\n\n    // Sign an arbitrary message if the wallet supports it\n    const signMessage: MessageSignerWalletAdapterProps['signMessage'] | undefined = useMemo(\n        () =>\n            adapter && 'signMessage' in adapter\n                ? async (message) => {\n                      if (!connected) throw handleErrorRef.current(new WalletNotConnectedError(), adapter);\n                      return await adapter.signMessage(message);\n                  }\n                : undefined,\n        [adapter, connected]\n    );\n\n    // Sign in if the wallet supports it\n    const signIn: SignInMessageSignerWalletAdapterProps['signIn'] | undefined = useMemo(\n        () =>\n            adapter && 'signIn' in adapter\n                ? async (input) => {\n                      return await adapter.signIn(input);\n                  }\n                : undefined,\n        [adapter]\n    );\n\n    const handleConnect = useCallback(async () => {\n        if (isConnectingRef.current || isDisconnectingRef.current || wallet?.adapter.connected) return;\n        if (!wallet) throw handleErrorRef.current(new WalletNotSelectedError());\n        const { adapter, readyState } = wallet;\n        if (!(readyState === WalletReadyState.Installed || readyState === WalletReadyState.Loadable))\n            throw handleErrorRef.current(new WalletNotReadyError(), adapter);\n        isConnectingRef.current = true;\n        setConnecting(true);\n        try {\n            await adapter.connect();\n        } catch (e) {\n            onConnectError();\n            throw e;\n        } finally {\n            setConnecting(false);\n            isConnectingRef.current = false;\n        }\n    }, [onConnectError, wallet]);\n\n    const handleDisconnect = useCallback(async () => {\n        if (isDisconnectingRef.current) return;\n        if (!adapter) return;\n        isDisconnectingRef.current = true;\n        setDisconnecting(true);\n        try {\n            await adapter.disconnect();\n        } finally {\n            setDisconnecting(false);\n            isDisconnectingRef.current = false;\n        }\n    }, [adapter]);\n\n    return (\n        <WalletContext.Provider\n            value={{\n                autoConnect: !!onAutoConnectRequest,\n                wallets,\n                wallet,\n                publicKey,\n                connected,\n                connecting,\n                disconnecting,\n                select: onSelectWallet,\n                connect: handleConnect,\n                disconnect: handleDisconnect,\n                sendTransaction,\n                signTransaction,\n                signAllTransactions,\n                signMessage,\n                signIn,\n            }}\n        >\n            {children}\n        </WalletContext.Provider>\n    );\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}