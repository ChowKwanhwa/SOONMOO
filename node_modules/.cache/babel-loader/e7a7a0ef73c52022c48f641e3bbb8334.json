{"ast":null,"code":"/**\n * \"Client\" wraps \"ws\" or a browser-implemented \"WebSocket\" library\n * according to the environment providing JSON RPC 2.0 support on top.\n * @module Client\n */\n\"use strict\";\n\nvar _defineProperty = require(\"/workspaces/SOONMOO/node_modules/@babel/runtime/helpers/defineProperty.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n// @ts-ignore\nconst eventemitter3_1 = require(\"eventemitter3\");\nconst utils_1 = require(\"./utils\");\nclass CommonClient extends eventemitter3_1.EventEmitter {\n  /**\n   * Instantiate a Client class.\n   * @constructor\n   * @param {webSocketFactory} webSocketFactory - factory method for WebSocket\n   * @param {String} address - url to a websocket server\n   * @param {Object} options - ws options object with reconnect parameters\n   * @param {Function} generate_request_id - custom generation request Id\n   * @param {DataPack} dataPack - data pack contains encoder and decoder\n   * @return {CommonClient}\n   */\n  constructor(webSocketFactory) {\n    let address = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"ws://localhost:8080\";\n    let {\n      autoconnect = true,\n      reconnect = true,\n      reconnect_interval = 1000,\n      max_reconnects = 5,\n      ...rest_options\n    } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    let generate_request_id = arguments.length > 3 ? arguments[3] : undefined;\n    let dataPack = arguments.length > 4 ? arguments[4] : undefined;\n    super();\n    _defineProperty(this, \"address\", void 0);\n    _defineProperty(this, \"rpc_id\", void 0);\n    _defineProperty(this, \"queue\", void 0);\n    _defineProperty(this, \"options\", void 0);\n    _defineProperty(this, \"autoconnect\", void 0);\n    _defineProperty(this, \"ready\", void 0);\n    _defineProperty(this, \"reconnect\", void 0);\n    _defineProperty(this, \"reconnect_timer_id\", void 0);\n    _defineProperty(this, \"reconnect_interval\", void 0);\n    _defineProperty(this, \"max_reconnects\", void 0);\n    _defineProperty(this, \"rest_options\", void 0);\n    _defineProperty(this, \"current_reconnects\", void 0);\n    _defineProperty(this, \"generate_request_id\", void 0);\n    _defineProperty(this, \"socket\", void 0);\n    _defineProperty(this, \"webSocketFactory\", void 0);\n    _defineProperty(this, \"dataPack\", void 0);\n    this.webSocketFactory = webSocketFactory;\n    this.queue = {};\n    this.rpc_id = 0;\n    this.address = address;\n    this.autoconnect = autoconnect;\n    this.ready = false;\n    this.reconnect = reconnect;\n    this.reconnect_timer_id = undefined;\n    this.reconnect_interval = reconnect_interval;\n    this.max_reconnects = max_reconnects;\n    this.rest_options = rest_options;\n    this.current_reconnects = 0;\n    this.generate_request_id = generate_request_id || (() => ++this.rpc_id);\n    if (!dataPack) this.dataPack = new utils_1.DefaultDataPack();else this.dataPack = dataPack;\n    if (this.autoconnect) this._connect(this.address, {\n      autoconnect: this.autoconnect,\n      reconnect: this.reconnect,\n      reconnect_interval: this.reconnect_interval,\n      max_reconnects: this.max_reconnects,\n      ...this.rest_options\n    });\n  }\n  /**\n   * Connects to a defined server if not connected already.\n   * @method\n   * @return {Undefined}\n   */\n  connect() {\n    if (this.socket) return;\n    this._connect(this.address, {\n      autoconnect: this.autoconnect,\n      reconnect: this.reconnect,\n      reconnect_interval: this.reconnect_interval,\n      max_reconnects: this.max_reconnects,\n      ...this.rest_options\n    });\n  }\n  /**\n   * Calls a registered RPC method on server.\n   * @method\n   * @param {String} method - RPC method name\n   * @param {Object|Array} params - optional method parameters\n   * @param {Number} timeout - RPC reply timeout value\n   * @param {Object} ws_opts - options passed to ws\n   * @return {Promise}\n   */\n  call(method, params, timeout, ws_opts) {\n    if (!ws_opts && \"object\" === typeof timeout) {\n      ws_opts = timeout;\n      timeout = null;\n    }\n    return new Promise((resolve, reject) => {\n      if (!this.ready) return reject(new Error(\"socket not ready\"));\n      const rpc_id = this.generate_request_id(method, params);\n      const message = {\n        jsonrpc: \"2.0\",\n        method: method,\n        params: params || undefined,\n        id: rpc_id\n      };\n      this.socket.send(this.dataPack.encode(message), ws_opts, error => {\n        if (error) return reject(error);\n        this.queue[rpc_id] = {\n          promise: [resolve, reject]\n        };\n        if (timeout) {\n          this.queue[rpc_id].timeout = setTimeout(() => {\n            delete this.queue[rpc_id];\n            reject(new Error(\"reply timeout\"));\n          }, timeout);\n        }\n      });\n    });\n  }\n  /**\n   * Logins with the other side of the connection.\n   * @method\n   * @param {Object} params - Login credentials object\n   * @return {Promise}\n   */\n  async login(params) {\n    const resp = await this.call(\"rpc.login\", params);\n    if (!resp) throw new Error(\"authentication failed\");\n    return resp;\n  }\n  /**\n   * Fetches a list of client's methods registered on server.\n   * @method\n   * @return {Array}\n   */\n  async listMethods() {\n    return await this.call(\"__listMethods\");\n  }\n  /**\n   * Sends a JSON-RPC 2.0 notification to server.\n   * @method\n   * @param {String} method - RPC method name\n   * @param {Object} params - optional method parameters\n   * @return {Promise}\n   */\n  notify(method, params) {\n    return new Promise((resolve, reject) => {\n      if (!this.ready) return reject(new Error(\"socket not ready\"));\n      const message = {\n        jsonrpc: \"2.0\",\n        method: method,\n        params\n      };\n      this.socket.send(this.dataPack.encode(message), error => {\n        if (error) return reject(error);\n        resolve();\n      });\n    });\n  }\n  /**\n   * Subscribes for a defined event.\n   * @method\n   * @param {String|Array} event - event name\n   * @return {Undefined}\n   * @throws {Error}\n   */\n  async subscribe(event) {\n    if (typeof event === \"string\") event = [event];\n    const result = await this.call(\"rpc.on\", event);\n    if (typeof event === \"string\" && result[event] !== \"ok\") throw new Error(\"Failed subscribing to an event '\" + event + \"' with: \" + result[event]);\n    return result;\n  }\n  /**\n   * Unsubscribes from a defined event.\n   * @method\n   * @param {String|Array} event - event name\n   * @return {Undefined}\n   * @throws {Error}\n   */\n  async unsubscribe(event) {\n    if (typeof event === \"string\") event = [event];\n    const result = await this.call(\"rpc.off\", event);\n    if (typeof event === \"string\" && result[event] !== \"ok\") throw new Error(\"Failed unsubscribing from an event with: \" + result);\n    return result;\n  }\n  /**\n   * Closes a WebSocket connection gracefully.\n   * @method\n   * @param {Number} code - socket close code\n   * @param {String} data - optional data to be sent before closing\n   * @return {Undefined}\n   */\n  close(code, data) {\n    this.socket.close(code || 1000, data);\n  }\n  /**\n   * Enable / disable automatic reconnection.\n   * @method\n   * @param {Boolean} reconnect - enable / disable reconnection\n   * @return {Undefined}\n   */\n  setAutoReconnect(reconnect) {\n    this.reconnect = reconnect;\n  }\n  /**\n   * Set the interval between reconnection attempts.\n   * @method\n   * @param {Number} interval - reconnection interval in milliseconds\n   * @return {Undefined}\n   */\n  setReconnectInterval(interval) {\n    this.reconnect_interval = interval;\n  }\n  /**\n   * Set the maximum number of reconnection attempts.\n   * @method\n   * @param {Number} max_reconnects - maximum reconnection attempts\n   * @return {Undefined}\n   */\n  setMaxReconnects(max_reconnects) {\n    this.max_reconnects = max_reconnects;\n  }\n  /**\n   * Connection/Message handler.\n   * @method\n   * @private\n   * @param {String} address - WebSocket API address\n   * @param {Object} options - ws options object\n   * @return {Undefined}\n   */\n  _connect(address, options) {\n    clearTimeout(this.reconnect_timer_id);\n    this.socket = this.webSocketFactory(address, options);\n    this.socket.addEventListener(\"open\", () => {\n      this.ready = true;\n      this.emit(\"open\");\n      this.current_reconnects = 0;\n    });\n    this.socket.addEventListener(\"message\", _ref => {\n      let {\n        data: message\n      } = _ref;\n      if (message instanceof ArrayBuffer) message = Buffer.from(message).toString();\n      try {\n        message = this.dataPack.decode(message);\n      } catch (error) {\n        return;\n      }\n      // check if any listeners are attached and forward event\n      if (message.notification && this.listeners(message.notification).length) {\n        if (!Object.keys(message.params).length) return this.emit(message.notification);\n        const args = [message.notification];\n        if (message.params.constructor === Object) args.push(message.params);else\n          // using for-loop instead of unshift/spread because performance is better\n          for (let i = 0; i < message.params.length; i++) args.push(message.params[i]);\n        // run as microtask so that pending queue messages are resolved first\n        // eslint-disable-next-line prefer-spread\n        return Promise.resolve().then(() => {\n          this.emit.apply(this, args);\n        });\n      }\n      if (!this.queue[message.id]) {\n        // general JSON RPC 2.0 events\n        if (message.method) {\n          // run as microtask so that pending queue messages are resolved first\n          return Promise.resolve().then(() => {\n            var _message;\n            this.emit(message.method, (_message = message) === null || _message === void 0 ? void 0 : _message.params);\n          });\n        }\n        return;\n      }\n      // reject early since server's response is invalid\n      if (\"error\" in message === \"result\" in message) this.queue[message.id].promise[1](new Error(\"Server response malformed. Response must include either \\\"result\\\"\" + \" or \\\"error\\\", but not both.\"));\n      if (this.queue[message.id].timeout) clearTimeout(this.queue[message.id].timeout);\n      if (message.error) this.queue[message.id].promise[1](message.error);else this.queue[message.id].promise[0](message.result);\n      delete this.queue[message.id];\n    });\n    this.socket.addEventListener(\"error\", error => this.emit(\"error\", error));\n    this.socket.addEventListener(\"close\", _ref2 => {\n      let {\n        code,\n        reason\n      } = _ref2;\n      if (this.ready)\n        // Delay close event until internal state is updated\n        setTimeout(() => this.emit(\"close\", code, reason), 0);\n      this.ready = false;\n      this.socket = undefined;\n      if (code === 1000) return;\n      this.current_reconnects++;\n      if (this.reconnect && (this.max_reconnects > this.current_reconnects || this.max_reconnects === 0)) this.reconnect_timer_id = setTimeout(() => this._connect(address, options), this.reconnect_interval);\n    });\n  }\n}\nexports.default = CommonClient;","map":{"version":3,"names":["_defineProperty","require","default","Object","defineProperty","exports","value","eventemitter3_1","utils_1","CommonClient","EventEmitter","constructor","webSocketFactory","address","arguments","length","undefined","autoconnect","reconnect","reconnect_interval","max_reconnects","rest_options","generate_request_id","dataPack","queue","rpc_id","ready","reconnect_timer_id","current_reconnects","DefaultDataPack","_connect","connect","socket","call","method","params","timeout","ws_opts","Promise","resolve","reject","Error","message","jsonrpc","id","send","encode","error","promise","setTimeout","login","resp","listMethods","notify","subscribe","event","result","unsubscribe","close","code","data","setAutoReconnect","setReconnectInterval","interval","setMaxReconnects","options","clearTimeout","addEventListener","emit","_ref","ArrayBuffer","Buffer","from","toString","decode","notification","listeners","keys","args","push","i","then","apply","_message","_ref2","reason"],"sources":["/workspaces/SOONMOO/node_modules/rpc-websockets/dist/lib/client.js"],"sourcesContent":["/**\n * \"Client\" wraps \"ws\" or a browser-implemented \"WebSocket\" library\n * according to the environment providing JSON RPC 2.0 support on top.\n * @module Client\n */\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// @ts-ignore\nconst eventemitter3_1 = require(\"eventemitter3\");\nconst utils_1 = require(\"./utils\");\nclass CommonClient extends eventemitter3_1.EventEmitter {\n    address;\n    rpc_id;\n    queue;\n    options;\n    autoconnect;\n    ready;\n    reconnect;\n    reconnect_timer_id;\n    reconnect_interval;\n    max_reconnects;\n    rest_options;\n    current_reconnects;\n    generate_request_id;\n    socket;\n    webSocketFactory;\n    dataPack;\n    /**\n     * Instantiate a Client class.\n     * @constructor\n     * @param {webSocketFactory} webSocketFactory - factory method for WebSocket\n     * @param {String} address - url to a websocket server\n     * @param {Object} options - ws options object with reconnect parameters\n     * @param {Function} generate_request_id - custom generation request Id\n     * @param {DataPack} dataPack - data pack contains encoder and decoder\n     * @return {CommonClient}\n     */\n    constructor(webSocketFactory, address = \"ws://localhost:8080\", { autoconnect = true, reconnect = true, reconnect_interval = 1000, max_reconnects = 5, ...rest_options } = {}, generate_request_id, dataPack) {\n        super();\n        this.webSocketFactory = webSocketFactory;\n        this.queue = {};\n        this.rpc_id = 0;\n        this.address = address;\n        this.autoconnect = autoconnect;\n        this.ready = false;\n        this.reconnect = reconnect;\n        this.reconnect_timer_id = undefined;\n        this.reconnect_interval = reconnect_interval;\n        this.max_reconnects = max_reconnects;\n        this.rest_options = rest_options;\n        this.current_reconnects = 0;\n        this.generate_request_id = generate_request_id || (() => ++this.rpc_id);\n        if (!dataPack)\n            this.dataPack = new utils_1.DefaultDataPack();\n        else\n            this.dataPack = dataPack;\n        if (this.autoconnect)\n            this._connect(this.address, {\n                autoconnect: this.autoconnect,\n                reconnect: this.reconnect,\n                reconnect_interval: this.reconnect_interval,\n                max_reconnects: this.max_reconnects,\n                ...this.rest_options\n            });\n    }\n    /**\n     * Connects to a defined server if not connected already.\n     * @method\n     * @return {Undefined}\n     */\n    connect() {\n        if (this.socket)\n            return;\n        this._connect(this.address, {\n            autoconnect: this.autoconnect,\n            reconnect: this.reconnect,\n            reconnect_interval: this.reconnect_interval,\n            max_reconnects: this.max_reconnects,\n            ...this.rest_options\n        });\n    }\n    /**\n     * Calls a registered RPC method on server.\n     * @method\n     * @param {String} method - RPC method name\n     * @param {Object|Array} params - optional method parameters\n     * @param {Number} timeout - RPC reply timeout value\n     * @param {Object} ws_opts - options passed to ws\n     * @return {Promise}\n     */\n    call(method, params, timeout, ws_opts) {\n        if (!ws_opts && \"object\" === typeof timeout) {\n            ws_opts = timeout;\n            timeout = null;\n        }\n        return new Promise((resolve, reject) => {\n            if (!this.ready)\n                return reject(new Error(\"socket not ready\"));\n            const rpc_id = this.generate_request_id(method, params);\n            const message = {\n                jsonrpc: \"2.0\",\n                method: method,\n                params: params || undefined,\n                id: rpc_id\n            };\n            this.socket.send(this.dataPack.encode(message), ws_opts, (error) => {\n                if (error)\n                    return reject(error);\n                this.queue[rpc_id] = { promise: [resolve, reject] };\n                if (timeout) {\n                    this.queue[rpc_id].timeout = setTimeout(() => {\n                        delete this.queue[rpc_id];\n                        reject(new Error(\"reply timeout\"));\n                    }, timeout);\n                }\n            });\n        });\n    }\n    /**\n     * Logins with the other side of the connection.\n     * @method\n     * @param {Object} params - Login credentials object\n     * @return {Promise}\n     */\n    async login(params) {\n        const resp = await this.call(\"rpc.login\", params);\n        if (!resp)\n            throw new Error(\"authentication failed\");\n        return resp;\n    }\n    /**\n     * Fetches a list of client's methods registered on server.\n     * @method\n     * @return {Array}\n     */\n    async listMethods() {\n        return await this.call(\"__listMethods\");\n    }\n    /**\n     * Sends a JSON-RPC 2.0 notification to server.\n     * @method\n     * @param {String} method - RPC method name\n     * @param {Object} params - optional method parameters\n     * @return {Promise}\n     */\n    notify(method, params) {\n        return new Promise((resolve, reject) => {\n            if (!this.ready)\n                return reject(new Error(\"socket not ready\"));\n            const message = {\n                jsonrpc: \"2.0\",\n                method: method,\n                params\n            };\n            this.socket.send(this.dataPack.encode(message), (error) => {\n                if (error)\n                    return reject(error);\n                resolve();\n            });\n        });\n    }\n    /**\n     * Subscribes for a defined event.\n     * @method\n     * @param {String|Array} event - event name\n     * @return {Undefined}\n     * @throws {Error}\n     */\n    async subscribe(event) {\n        if (typeof event === \"string\")\n            event = [event];\n        const result = await this.call(\"rpc.on\", event);\n        if (typeof event === \"string\" && result[event] !== \"ok\")\n            throw new Error(\"Failed subscribing to an event '\" + event + \"' with: \" + result[event]);\n        return result;\n    }\n    /**\n     * Unsubscribes from a defined event.\n     * @method\n     * @param {String|Array} event - event name\n     * @return {Undefined}\n     * @throws {Error}\n     */\n    async unsubscribe(event) {\n        if (typeof event === \"string\")\n            event = [event];\n        const result = await this.call(\"rpc.off\", event);\n        if (typeof event === \"string\" && result[event] !== \"ok\")\n            throw new Error(\"Failed unsubscribing from an event with: \" + result);\n        return result;\n    }\n    /**\n     * Closes a WebSocket connection gracefully.\n     * @method\n     * @param {Number} code - socket close code\n     * @param {String} data - optional data to be sent before closing\n     * @return {Undefined}\n     */\n    close(code, data) {\n        this.socket.close(code || 1000, data);\n    }\n    /**\n     * Enable / disable automatic reconnection.\n     * @method\n     * @param {Boolean} reconnect - enable / disable reconnection\n     * @return {Undefined}\n     */\n    setAutoReconnect(reconnect) {\n        this.reconnect = reconnect;\n    }\n    /**\n     * Set the interval between reconnection attempts.\n     * @method\n     * @param {Number} interval - reconnection interval in milliseconds\n     * @return {Undefined}\n     */\n    setReconnectInterval(interval) {\n        this.reconnect_interval = interval;\n    }\n    /**\n     * Set the maximum number of reconnection attempts.\n     * @method\n     * @param {Number} max_reconnects - maximum reconnection attempts\n     * @return {Undefined}\n     */\n    setMaxReconnects(max_reconnects) {\n        this.max_reconnects = max_reconnects;\n    }\n    /**\n     * Connection/Message handler.\n     * @method\n     * @private\n     * @param {String} address - WebSocket API address\n     * @param {Object} options - ws options object\n     * @return {Undefined}\n     */\n    _connect(address, options) {\n        clearTimeout(this.reconnect_timer_id);\n        this.socket = this.webSocketFactory(address, options);\n        this.socket.addEventListener(\"open\", () => {\n            this.ready = true;\n            this.emit(\"open\");\n            this.current_reconnects = 0;\n        });\n        this.socket.addEventListener(\"message\", ({ data: message }) => {\n            if (message instanceof ArrayBuffer)\n                message = Buffer.from(message).toString();\n            try {\n                message = this.dataPack.decode(message);\n            }\n            catch (error) {\n                return;\n            }\n            // check if any listeners are attached and forward event\n            if (message.notification && this.listeners(message.notification).length) {\n                if (!Object.keys(message.params).length)\n                    return this.emit(message.notification);\n                const args = [message.notification];\n                if (message.params.constructor === Object)\n                    args.push(message.params);\n                else\n                    // using for-loop instead of unshift/spread because performance is better\n                    for (let i = 0; i < message.params.length; i++)\n                        args.push(message.params[i]);\n                // run as microtask so that pending queue messages are resolved first\n                // eslint-disable-next-line prefer-spread\n                return Promise.resolve().then(() => { this.emit.apply(this, args); });\n            }\n            if (!this.queue[message.id]) {\n                // general JSON RPC 2.0 events\n                if (message.method) {\n                    // run as microtask so that pending queue messages are resolved first\n                    return Promise.resolve().then(() => {\n                        this.emit(message.method, message?.params);\n                    });\n                }\n                return;\n            }\n            // reject early since server's response is invalid\n            if (\"error\" in message === \"result\" in message)\n                this.queue[message.id].promise[1](new Error(\"Server response malformed. Response must include either \\\"result\\\"\" +\n                    \" or \\\"error\\\", but not both.\"));\n            if (this.queue[message.id].timeout)\n                clearTimeout(this.queue[message.id].timeout);\n            if (message.error)\n                this.queue[message.id].promise[1](message.error);\n            else\n                this.queue[message.id].promise[0](message.result);\n            delete this.queue[message.id];\n        });\n        this.socket.addEventListener(\"error\", (error) => this.emit(\"error\", error));\n        this.socket.addEventListener(\"close\", ({ code, reason }) => {\n            if (this.ready) // Delay close event until internal state is updated\n                setTimeout(() => this.emit(\"close\", code, reason), 0);\n            this.ready = false;\n            this.socket = undefined;\n            if (code === 1000)\n                return;\n            this.current_reconnects++;\n            if (this.reconnect && ((this.max_reconnects > this.current_reconnects) ||\n                this.max_reconnects === 0))\n                this.reconnect_timer_id = setTimeout(() => this._connect(address, options), this.reconnect_interval);\n        });\n    }\n}\nexports.default = CommonClient;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script"}